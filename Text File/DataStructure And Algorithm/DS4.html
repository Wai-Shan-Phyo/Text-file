<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body>Data Structure (Part - 4)<br><br>Data Structure (Part - 4)<br>====================<br><br>Problem-oriented data structure<br>-----------------------------------------------------<br>Problem-oriented data structure တွေကလဲ အထူးတလည်မဟုတ်ပဲ basic data structure တွေဖြစ်တဲ့ array type, pointer type စတာတွေကိုပဲ ပြန်ပြီး designed လုပ်ထားတဲ့ data structure တွေပဲ ဖြစ်ပါတယ်။<br><br>List Structure<br>-----------------------<br>List Structure ဆိုတာကတော့ basic data structure ထဲက Array type နဲ့ ဆင်တယ်။ ဒါမဲ့ array type နဲ့မတူတာက list ထဲမှာ ရှိတဲ့ data တစ်ခုချင်းစီကို handle လုပ်နိုင်တယ်။ list ထဲက data တွေကို ပြင်တာတွေ၊ ဖျက်တာတွေ၊ data အသစ်ထည့်တာတွေ လုပ်နိုင်တယ်။ ဒါက list type နဲ့ array type မတူတဲ့ အချက်ပါ။ data တွေကို အောက်က list structure တွေနဲ့ arrange လုပ်ထားရင် list လို့ သက်မှတ်လို့ရပါတယ်။<br><br>1) List structure and cell<br>-------------------------------------<br>Array ထဲမှာ ရှိတဲ့ element တစ်ခုချင်းစီကို subscript (index) သုံးပြီး စိတ်ကြိုက် ပြင်လို့ရပါတယ်။ ဥပမာ - [apple, banana, orange] array ရှိတယ်ဆိုပါစို့။ array ခန်း (1) က element ကို lemon လို့ ပြောင်းလိုက်ရင် [apple, lemon, orange] ဆိုပြီးဖြစ်သွားမှာပါ။ Data တစ်ခုအသစ်ထည့်ပြီဆိုရင်လဲ ဘယ် array ခန်းရဲ့ အနောက်မှာ ထည့်မှာဆိုပြီး subscript နဲ့ defined လုပ်လိုက်ရင် အဲ့နေရာမှာ data ၀င်သွားပြီး သူ့နောက်က element တွေကတော့ နောက်ကို တခန်းစီ ဆုတ်သွားမှာ (shift လုပ်သွားမှာ) ပါ။ delete လုပ်ရင်လဲ ဒီတိုင်းပါပဲ။ delete ကျ နောက်က element တွေက ရှေ့ကို ရွှေ့လာတာပေါ့။ array type နဲ့ မတူတဲ့အဓိကအချက်က အဲ့တာပါ။ list type မှာ data elements တွေကို စိတ်ကြိုက် အလွယ်လေး ကစားလို့ရတာပါပဲ။<br><br>Data arrange လုပ်တဲ့အပိုင်းကတော့ list နဲ့ array က အတူတူပါပဲ။ ဒါမဲ့ နောက်ထပ် မတူတာ တစ်ခုက main memory unit မှာ သိမ်းတဲ့ပုံစံပါ။ array type မှာ ဘယ်လို သိမ်းလဲဆို‌တာတော့ ရှေ့က အပိုင်းတွေမှာ ပြောပြခဲ့ပြီးပါပြီ။ ဒီအပိုင်းမှာတော့ list Type ရဲ့ main memory unit မှာ သိမ်းပုံသိမ်းနည်းကို ပြောပြပေးပါမယ်။<br><br>List type မှာ cell တွေပါဝင်ပါတယ်။ cell တစ်ခုချင်းစီမှာ Data Section နဲ့ Pointer Section ဆိုပြီး section နှစ်ခုပါ ပါတယ်။ Data section ကတော့ data element အတွက် ဖြစ်ပြီးတော့ pointer section ကတော့ data element ရဲ့ address အတွက်ပါ။ အဲ့တော့ ဘယ်လိုပုံစံဖြစ်သွားလဲဆိုရင် record type လိုမျိုး data : pointer ဖြစ်သွားပါတယ်။ ဒါ့အပြင် cell တစ်ခုနဲ့ တစ်ခုကလဲ pointer နဲ့ ချိတ်ထားပါတယ်။ ဘယ်လိုချိတ်ထားလဲဆိုရင် နောက် data ရဲ့ pointer က ရှေ့ data ရဲ့ pointer မှာ ချိတ်ထားပါတယ်။ ဥပမာ <br><br>Apple : Address of Orange, Orange : Address of Banana, Banana: Address of n<br>(Data : Pointer) &lt;- (Data : Pointer) &lt;- (Data : Pointer) &lt;-<br><br>2) Inserting data into a list<br>---------------------------------------------<br>List ထဲကို data ဘယ်လိုထည့်လဲ ဆိုတာ အပေါ်မှာ သဘောတရားအရ ပြောခဲ့ပြီးပါပြီ။ ဒီအပိုင်းမှာကတော့ နဲနဲ detail ကျသွားမှာပေါ့။ အဲ့တော့ ဘယ်လို insert လုပ်လဲဆိုရင် ဘယ် subscript ရဲ့ နောက်မှာ insert လုပ်မယ်ဆိုပြီး defined လုပ်လိုက်ရင် အဲ့ subscript ရဲ့ နေရာမှာ data element ၀င်လာမယ်။ သူ့နောက်က element တွေက အနောက်ကို shift (ရွေ့) သွားမယ်။ <br><br>Detail ကျကျ ဆိုရင်တော့ အဲ့၀င်လာမဲ့ နေရာ (ဥပမာ ၁ နဲ့ ၂ ကြား)မှာ ရှေ့က subscript ရဲ့ pointer section ကို replace လုပ်လိုက်တာပါ။ ဘာနဲ့ replace လုပ်လဲဆိုရင် အသစ်၀င်လာမဲ့ cell က data element ရဲ့ address နဲ့ပါ။ သူ့ရဲ့ pointer section မှာတော့ နောက်ကို ‌shift လုပ်သွားတဲ့ data element ရဲ့ address က လာထည့်မှာပါ။ သူ့နောက်က data element တွေကတော့ ရှေ့မှာ data insert ၀င်လာတဲ့အတွက် သူတို့က အလိုလို နောက်ကို shift&nbsp; ရွှေ့သွားမှာပါ။ ဒီလိုဆိုတခါထဲ cell joint ဖြစ်ပြီး list ထဲ data insert လုပ်တဲ့အပိုင်းကလဲ ပြီးမြောက်သွားပါပြီ။<br><br>3) Deleting data from a list <br>---------------------------------------------<br>Delete လုပ်ရင်လဲ insert လိုပါပဲ။ pointer တွေကို replace လုပ်လိုက်တာပါ။ Replace လုပ်ပုံလုပ်နည်းကတော့ Delete လုပ်မဲ့ cell ရဲ့ pointer section က address ကို ဖျက်ချပြီး သူ့ရှေ့က cell ရဲ့ pointer section မှာ replace လုပ်လိုက်ပါတယ်။ အဲ့ခါကျ သူ့ရှေ့က pointer section မှာရှိနေတဲ့ သူ့ရဲ့ address ပါ ဖျက်ခံထိသွားပြီး သူ့ရှေ့က cell ရဲ့ pointer section ကတော့ သူ့နောက်က cell နဲ့ joint ဖြစ်သွားတာကြောင့် data delete လုပ်တဲ့ကိစ္စက အောင်မြင်သွားမှာပါ။ delete လုပ်ခံလိုက်ရတဲ့ cell နေရာကတော့ memory မှာ garbage အနေနဲ့ ကျန်ရှိနေမှာပါ။ <br><br>List type ဟာ inserting/ deleting လုပ်ရတာ လွယ်ကူနေပေမဲ့လဲ သူ့မှာ အားနည်းချက်တစ်ခုရှိပါတယ်။ အဲ့တာကတော့ ကိုယ် access လုပ်ချင်တဲ့ cell တစ်ခုကို လုပ်ဖို့အတွက် cell တွေကို အစကနေ one by one tracking လိုက်နေရတာပါ။<br><br>4) Types of list structures<br>---------------------------------------<br>List structure အမျိုးအစား သုံးမျိုးရှိပါတယ်။ <br><br>1) Uni-directional list<br>2) Bi-directional list<br>3) Ring list <br><br>Uni-directional list<br>-------------------------------<br>Uni-directional list ကို one-way list လို့လဲခေါ်ပါတယ်။ သူရဲ့ ပုံစံက ကျွန်တော် အပေါ်မှာ ဥပမာ ပေးခဲ့တဲ့ list type နဲ့ အတူတူပါပဲ။ ရှေ့က cell ရဲ့ pointer section မှာ နောက်က cell ရဲ့ data section က address ကို သိမ်းတယ်။ ဒီလိုနဲ့ cell အကုန်လုံးကို chain သဘောမျိုး ချိတ်ဆက်ထားတဲ့ type ပါ။ <br><br>ဆိုတော့ မေးစရာရှိတာက ရှေ့ဆုံး cell က data section ရဲ့ address ကို ဘယ်မှာသွားသိမ်းသလဲ ဆိုတာနဲ့ နောက်ဆုံး cell ရဲ့ pointer section မှာ ဘာသိမ်းသလဲ ဆိုတာပါ။ <br><br>အ‌ဖြေက ရှေ့ဆုံး cell က data section ရဲ့ address ကို သိမ်းဖို့အတွက် Uni-directional list မှာ root (ဒါမှမဟုတ်) head ဆိုတဲ့ကောင် ရှိပါတယ်။ အဲ့ကောင်က Uni-directional list ရဲ့ ထိပ်ဆုံးမှာ အမြဲရှိပြီး first cell က data section ရဲ့ address ကို သိမ်းပေးပါတယ်။ နောက်ဆုံး cell ရဲ့ pointer section မှာ သိမ်းဖို့အတွက် သူ့အနောက်မှာ ဘာ cell မှ မရှိတော့တဲ့ အခါကျ NULL value ကိုသိမ်းပါတယ်။<br><br>Uni-directional list က one-way list ဖြစ်တာကြောင့် pointer တွေကို one by one tracking လိုက်ရင်းနဲ့ ကိုယ်လိုချင်တဲ့ ‌data ကို ရှာလို့ရပါတယ်။<br><br>Bi-directional list<br>-----------------------------<br>Bi-directional list မှာတော့ cell တစ်ခုမှာ pointer section နှစ်ခုပါပါတယ်။ data section ရဲ့ ရှေ့နဲ့ နောက်မှာ တစ်ခုစီ နေရာယူထားပါတယ်။ <br><br>First cell ရဲ့ first pointer section မှာ head ပါပြီးတော့ last cell ရဲ့ first pointer section မှာ tail ဆိုပြီး ပါပါတယ်။ pointer section မှာ address သိမ်းပုံသိမ်းနည်းကတော့ Uni-directional list နဲ့ ဆင်တူပါတယ်။ data section ရဲ့ address ကို first pointer section မှာ သိမ်းပါတယ်။ အဲ့ first pointer section ကို ရှေ့က cell ရဲ့ second pointer section နဲ့ လှမ်းချိတ်ပါတယ်။ <br><br>First cell data section ရဲ့ address ကိုတော့ head မှာသိမ်းပြီးတော့ last cell ရဲ့ second pointer section မှာတော့ NULL value ပဲသိမ်းပါတယ်။ သူကတော့ Bi-directional list ဖြစ်တာနဲ့အညီ data ရှာရင်လဲ head ကနေရော tale ကနေရော ဖင်တပြန် ခေါင်းတပြန် ပတ်ရှာလို့ရပါတယ်။<br><br>Ring list<br>---------------<br>Ring list လဲ ရှင်းပါတယ်။ Bi-directional list လိုပဲ pointer section နှစ်ခုပါပါတယ်။ last cell ရဲ့ second pointer section မှာ NULL ကို မသိမ်းတော့ပဲ first cell ရဲ့ head ကိုလာသိမ်းပါတယ်။ first cell ရဲ့ first pointer section မှာကျတော့ tale ကို တစ်ခါ လာပြန်သိမ်းပါတယ်။ အဲ့ခါကျ list က ring type ဖြစ်သွားပါတယ်။ Ring type ကလဲ Bi-directional list လိုပဲ data ကိုရှေ့နောက် ပတ်ချာလည်လိုက်ပြီး ရှာလို့ရပါတယ်။<br><br>[Note: အောက်က ပုံနဲ့တွဲပြီး လေ့လာရန်။]<br><br>Web Developing Channel - WDC<br>#wdc</body></html>