<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body>Gentle Introduction to how DBMS work internally<br><br>DBMS <a href="http://လို.ဆိုလိုက်လို.ရှိရင်">လို.ဆိုလိုက်လို.ရှိရင်</a> စာအုပ်တော်တော်များများက database design အကြောင်းကိုပဲရှင်းတာများတယ်။ စျေးကွက်မှာလဲ အဲ့လိုစာအုပ်တွေချည်းပဲ။ DBMS ကိုအထဲမှာဘယ်လိုတည်ဆောက်ထားတယ် ဘာတွေပါတယ်ဆိုတာရှင်းထားတဲ့ စာအုပ်က literature မှာတောင် ၂အုပ်လားရယ်ပဲရှိတယ်။ Compiler အကြောင်းတွေ OS အလုပ်လုပ်ပုံတွေ ရေးထားတဲ့စာအုပ်ကတော့ အတော်များတယ်။ ဒါကြောင့် Java company Sun ကို Database company Oracle <a href="http://ကဝယ်သွားလို.ရတာလားလို.တောင်">ကဝယ်သွားလို.ရတာလားလို.တောင်</a> စဉ်းစားမိတယ် :3 ။ Business Application တခုလုပ်ပြီဆိုရင် အနည်းဆုံး data ကသိမ်းရတော့မယ်။ အဲ့တော့ DBMS က မပါမဖြစ် ပါလာတယ်။ DBMS တွေ မပေါ်ခင်က ဘယ်လိုသိမ်းလဲဆိုရင် file sytem မှာပဲသိမ်းတယ်။ အဲတော့ access, retrieval က ခက်တယ်။ <br><br>နောက်ပိုင်း IBM ကနေ&nbsp; Codd ရဲ. Relational Algebra သီအိုရီ ထွက်လာတော့ DBMS တွေပေါ်လာတယ်။ Relational Algebra ဆိုတာသိချင်ရင်တော့ စာလိုက်ဖတ်။ <br>သာမာန်အားဖြင့် Application မှာ DBMS ကိုဘယ်လိုသုံးလဲဆိုရင် API တွေသုံးပြီးတော့ access လုပ်တယ်။ API ကနေ return ပြန်တဲ့ data ကိုသုံးမယ်။ API ကနေ database ကိုချိတ်ပြီးတော့ CRUD တွေလုပ်ကြတယ်ပေါ့။ ပြဿနာက <a href="http://အဲ့တာတွေရဲ.နောက်မှာ">အဲ့တာတွေရဲ.နောက်မှာ</a> တဆင့်ခြင်းဘယ်လိုလုပ်သွားလဲဆိုတာပဲ။ သိတော့ဘာထူးမှာလဲဆိုတဲ့ မြေယိုးတွေတော့ <a href="http://ဖတ်ဖို.မလိုဘူး">ဖတ်ဖို.မလိုဘူး</a>။ အဲ့ဒါတွေသိထားရင် DBMS ကို လွှတ်လိုက်တဲ့ SQL တကြောင်းအတွက် DBMS သည် ဘယ်လိုအလုပ်လုပ်သွားရသလဲဆိုတာသိလာမယ်။ အကျိုးဆက်အနေနဲ. အနည်းဆုံး SQL ကိုဘယ်လို Optimize ဖြစ်အောင်ရေးရမလဲ ဆိုတာသိလာမယ်။ <br><br>နောက် DBMS ကိုယ်စား စဉ်းစားတတ်လာမယ်။ (တကယ်တော့ အဲ့လောက်ထိတော့မလွယ်ပါဘူး <a href="http://ဘာလို.လဲဆိုတော့">ဘာလို.လဲဆိုတော့</a> DBMS <a href="http://တခုနဲ.တခု">တခုနဲ.တခု</a> query optimizer တွေ အလုပ်လုပ်ပုံမတူကြသလို ထုတ်လဲမပြောကြတော့ သာမာန်အားဖြင့် သဘောတရားလောက်ကိုပဲသိနိုင်မယ်)။ နောက်တခုက DBMS တွေမှာ query execution plan ကိုထုတ်ကြည့်နိုင်တဲ့ tool တွေရှိတယ်။ Query execution plan ဆိုတာ ရှင်းအောင်ပြောရရင် ကိုရေးလိုက်တဲ့ SQL ကိုဘယ်လိုအဆင့်တွေ သုံးပြီး အဆင့်ဆင့်လုပ်သွားမလဲ ။နောက် တဆင့်ချင်းဆီမှာ ဘယ်လောက် cost ကျမလဲ (ဘယ်လောက် အချိန်ကြာမလဲ memory ဘယ်လောက်ကုန်မလဲ) <a href="http://ဒါတွေကိုကြည့်လို.ရတယ်">ဒါတွေကိုကြည့်လို.ရတယ်</a>။ အဲ့တော့ performance အရ tuning လုပ်ချင်ရင် ဒါတွေက အရေးပါလာပြီ။ တကယ်က အဲ့လို အလုပ်တွေကျတော့ ဆိုင်ရာ DBA ကလုပ်ရတယ်။ ဒါပေသိ Organization တိုင်းမှာ DBA ရှိချင်မှ ရှိမယ်။ <br><br>Programmer တယောက်အတွက်သိထားရင်လဲ အသုံးဝင်တယ်။ MySQL workbench မှာဆို visually ပါပြနိုင်တယ် query execution plan ကို။ Explain ကိုသုံးရင်လဲရတယ်။ စိတ်ဝင်စားရင် ဒီမှာသွားကြည့် <br><a href="https://dev.mysql.com/.../en/wb-performance-explain.html">https://dev.mysql.com/.../en/wb-performance-explain.html</a><br>ဥပမာ Java program တခုကနေ MySQL ကို သုံးပြီဆိုရင် JDBC API <br>တွေကနေ လှမ်းသုံးရတယ်။ MysQL သည် C/C++ <a href="http://နဲ.ရေးထားတာ">နဲ.ရေးထားတာ</a>။ အဲ့တာကိုဘယ်လိုလုပ် JDBC Java ကနေ <a href="http://လှမ်းခေါ်လို.ရလဲဆိုတော့">လှမ်းခေါ်လို.ရလဲဆိုတော့</a> JDBC driver တွေကြောင့်။ JDBC Driver တွေက ဘာလုပ်လဲဆိုတော့ MySQL database server ကို TCP protocol ကနေ လှမ်းဆက်သွယ်တယ်။ ပြီးတော့မှ Socket က ရလာတဲ့ data တွေကို API ကိုပြန်ပေးတယ်။ ဒါကြောင့် TCP/IP protocol <a href="http://ကိုသုံးလို.သာ">ကိုသုံးလို.သာ</a> DMBS တွေသည် different langauge ကနေ access <a href="http://လုပ်လို.ရတာ">လုပ်လို.ရတာ</a>။ <br><br>MySQL သည် port <a href="tel:3306">3306</a> ကိုသုံးတယ်။ ဘာကြောင့် TCP ကိုသုံးတုံးပေါ့။ ရှင်းတယ်။ UDP က data ပျောက်နိုင်တယ်။ database လို stream data တွေ <a href="http://ပို.မယ်ဆိုရင်">ပို.မယ်ဆိုရင်</a> TCP ကိုသုံးတာပဲအဆင်ပြေတယ်။ဒါကြောင့် database connection တခုချိတ်တိုင်းသည် လေးတယ် performance ကိုထိတယ် ဆိုတာ TCP connection ချိတ်ရတယ်။ နောက် ဟိုဘက်က MySQL server မှာလဲ database connection ကိုထိန်းဖို. process managment တွေလုပ်ရတယ်(Process manangement ကိုသိချင်ရင်တော့ Operating System စာအုပ်တွေရှာဖတ်ပေါ့) ဒါကြောင့် developer တွေသည် connection polling လိုကောင်မျိုးကိုသုံးတယ်။ <br>အပေါ်က ပုံက technical report (paper <a href="http://လို.မဆိုချင်တာက">လို.မဆိုချင်တာက</a> စာမျက်နှာ ၁၅၀ လောက်ရှိနေလို.) ကနေ ယူထားတာ။<br><br>Connection ချိတ်ပြီးရင် SQL command တွေကို program <a href="http://ကနေပို.လို.ရပြီ">ကနေပို.လို.ရပြီ</a>။ ခုနက Connection ချိတ်တာရယ် DBMS ကရလာတဲ့ result ရယ်ကိုထုတ်ပေးတာကို အပေါ်ပုံထဲက communication mananger ကလုပ်ပေးရတယ်။ SQL လေး client ဘက်ကနေရပြီဆိုရင် DBMS ကအထဲမှာ အဲ့ဒီ SQL ကို process လုပ်ဖို. thread ကလေး တခု ဖန်တီးလိုက်ရတယ်။ ဘာလို. Thread သုံးလဲဆိုရင်တော့ ဒီနေရာမှာ database server တခုသည် concurrent connection တွေကို create လုပ်နိုင်တယ် ဒါကြောင့် thread <a href="http://တခုချင်းဆီနဲ.ခွဲလုပ်တာ">တခုချင်းဆီနဲ.ခွဲလုပ်တာ</a> process တွေ create လုပ်တာထက်စာရင်ပိုသက်သာတယ် ဒါကြောင့်အဲ့လိုလုပ်တာ။ အဲ့လို thead တွေ process တွေ အတွက်အလုပ်လုပ်ပေးတာကတော့ Process Manager ဆိုတဲ့ module ကနေ လုပ်ပေးရတာ။ ခုနက SQL command တွေကို မ run ခင်မှာ ဘာလုပ်ရသေးလဲဆိုတော့ ဒီ client က လွှတ်လိုက်တဲ့ command တွေသည် client ရဲ. user permission အရ လုပ်ခွင့်ရှိသလားဆိုတာကို စစ်ရတယ် အဲ့ဒီအလုပ်ကိုကျတော့ Admission Control ဆိုတဲ့ module ကလုပ်တယ်။<br><br>ခုနက Admission ကလဲ အိုကေပြီ SQL command သည် user ကိုပေးသုံးထားတဲ့ ဘောင်ထဲကနေရှိတယ် ဒါဆိုရင် SQL command ကိုစ run <a href="http://လို.ရပြီပေါ့">လို.ရပြီပေါ့</a>။ ဒါဆိုရင် SQL ကို run <a href="http://ဖို.အတွက်">ဖို.အတွက်</a> Relational Query Processor <a href="http://ဆီကိုပို.ရတယ်">ဆီကိုပို.ရတယ်</a>။ Relational Query Processor <a href="http://ရဲ.အလုပ်က">ရဲ.အလုပ်က</a> SQL ကို compile လုပ်တယ်။ Compile လုပ်တယ်ဆိုတာက SQL statement ကို programming langauge တွေကို parse လုပ်သလို parse လုပ်တယ်။ ပြီးတော့ internal form ထုတ်တယ်။ Internal form ဆိုတာ DBMS ကနေ အထဲမှာသုံးထားတဲ့ basic operation တွေ JOIN,SELECT, Projection အစရှိတဲ့ operator <a href="http://တွေနဲ.ရေးထားတဲ့">တွေနဲ.ရေးထားတဲ့</a> intermediate code မျိုးပေါ့။ ခုနက SQL ကြီးကို parse လုပ်ပြီးရင် internal query plan <a href="http://အနေနဲ.ထုတ်တယ်">အနေနဲ.ထုတ်တယ်</a>။ <br>ဥပမာ <br>SELECT * FROM Student WHERE id=3;<br>အတွက် EXPLAIN SELECT * FROM Student WHERE id=3; <a href="http://လို.run">လို.run</a> လိုက်ရင် <a href="http://ဒါမျိုးတွေ.မယ်">ဒါမျိုးတွေ.မယ်</a><br>select_type SIMPLe,table course, type const, possible_keys=PRIMARY,key=PRIMARY,key_len=4,ref=const,row=1<br>အပေါ်က query plan သည် DBMS အထဲမှာသုံးသွားတဲ့ ဟာ ဟုတ်ချင်မှဟုတ်မယ် ဒါပေသိ SQL statement တကြောင်းကို basic relational operator (JOIN,SELECT,PROJECTION)အစရှိတာတွေအနဲ.&nbsp; ပြန်ပြောင်းလိုက်တာ မျိုးပဲဖြစ်တယ်။ <a href="http://ဘာလို.ပြန်ပြောင်းလဲဆိုတော့">ဘာလို.ပြန်ပြောင်းလဲဆိုတော့</a> programming language တွေလိုပဲ statement ကြီးတခုလုံးကို အထဲမှာ run ဖို. ဆိုင်ရာ ဆိုင်ရာ bytecode တွေ machine instruction တွေ run <a href="http://ဖို.အတွက်ပဲ">ဖို.အတွက်ပဲ</a>။ SQL ရဲ. သာမာန် programming language တွေထက် အားသာတာသည် သူသည် declarative language ဖြစ်တယ်။ Declarative ဆိုတာ ဘာလိုချင်တယ်ပဲပြောရတယ်။ ဥပမာ SQL မှာ ORDER BY ပဲပြောရတယ်။ ဘယ်လို Order လုပ်မယ် စီမယ်ဆိုတာ imperative langauge တွေလိုပြောစရာမလိုဘူး။ဆိုရင်ရာ column အလိုက် index <a href="http://ရှိမှူ.အပေါ်လိုက်ပြီး">ရှိမှူ.အပေါ်လိုက်ပြီး</a> database အထဲမှာ ဘယ်လိုလုပ်ရမလဲဆိုတာ <a href="http://သူ.ဘာသာ">သူ.ဘာသာ</a> ဆုံးဖြတ်သွားတယ်။ ဒါကြောင့် declarative <a href="http://လို.ခေါ်တယ်">လို.ခေါ်တယ်</a>။ Relational query processor ထဲမှာ ၃ ပိုင်းပါသေးတယ်။ <br><br>Query Parsing and Authorization <br>သူက query ကို parse လုပ်တယ်။ parse လုပ်တယ်ဆိုတဲ့နေရာမှာ query သည် grammar အရ မှန်မမှန်စစ်တယ်။အဲ့ဒါတင်မကဘူး သူသည် SQL မှာပါတဲ့ table name တွေ column တွေသည် <a href="http://တကယ်ရှိရဲ.လား">တကယ်ရှိရဲ.လား</a> <a href="http://အသုံးမှန်ရဲ.လားဆိုတာမျိုးပါစစ်တယ်">အသုံးမှန်ရဲ.လားဆိုတာမျိုးပါစစ်တယ်</a>။ ဒါမျိုးကိုဘယ်လိုစစ်လဲဆိုတော့ DBMS တွေမှာ metatable တွေရှိတယ် <a href="http://အဲ့ကောင်တွေနဲ.တိုက်ပြီးတော့စစ်ရတယ်">အဲ့ကောင်တွေနဲ.တိုက်ပြီးတော့စစ်ရတယ်</a>။ Catalog Manaer သည် metatable တွေကို ထိန်းသိမ်းတဲ့အလုပ်ကိုလုပ်ရတယ်။ Authorization ကတော့ ဒီ query မှာပါတဲ့ operation တွေကို user <a href="http://ကိုခွင့်ပေးထားရဲ.လားဆိုတာမျိုး">ကိုခွင့်ပေးထားရဲ.လားဆိုတာမျိုး</a> access priviledge ကိုစစ်တာမျိုးစစ်ရတယ်။<br><br>Query Rewrite <br>User က ရေးလိုက်တဲ့ SQL Query ကို ပိုပြီးမြန်အောင် rewrite လုပ်တဲ့သဘော တခါတလေ process လုပ်ရလွယ်အောင်လုပ်တာလဲ ပါမှာပေါ့။ ဥပမာ SELECT * FROM customer WHERE id= 2+3 ဒါဆို 2+3 ကို 5 <a href="http://နဲ.အစားထိုးလို.ရတယ်">နဲ.အစားထိုးလို.ရတယ်</a>။ Query rewrite လုပ်ရင် SELECT * FROM customer WHERE id = 5 ဆိုပြီး ဖြစ်သွားမယ်။ တခုသတိထားရမှာက query rewrite သည် မူရင်း SQL မှာလုပ်နေတာမဟုတ်ပဲ internal form မှာလုပ်နေတယ်ဆိုတာပဲ။<br><br>Query Optimizer<br>ဒီအပိုင်းကတော့ DBMS တခုမှာ အရေးအကြီးဆုံးအပိုင်းပဲ။ သူကဘာလုပ်လဲဆိုတော့ query plan ကို ပိုပြီးတော့ performance မြင့်အောင် ပြန်ပြင်ရေးတယ်။ ဥပမာ Table ၂ ခုကို JOIN တယ်ဆိုပါစို. နောက်ပြီး မှ ဒုတိယ table ထဲက filed တခုကို ပဲ WHERE <a href="http://နဲ.စစ်ထုတ်တယ်ဆိုပါစို">နဲ.စစ်ထုတ်တယ်ဆိုပါစို</a>. ။ဒါဆို&nbsp; Programmer က JOIN ကို အရင်ရေးပေမဲ့ Query optimizer သည် WHERE clause ကိုအရင်လုပ်မယ်။ <a href="http://ဘာလို.လဲဆိုတော့">ဘာလို.လဲဆိုတော့</a> WHERE ကိုအရင် လုပ်လိုက်ရင် ရလာမဲ့ row အရေအတွက်သည် ပိုနည်းသွားမယ် ။အဲ့တော့မှ နောက် table တခုနဲ. ထပ် JOIN ရင် result သည် memory ပေါ်မှာ တင်ရတာ ပိုသက်သာမယ် နည်းမယ် ပိုလဲမြန်မယ်ပေါ့။ JOIN သည် Caretsian product (ဒါတွေမသိရင် CJ Date စာအုပ်ပြေးလှန်ကြပေါ့) ဖြစ်တဲ့အတွက် WHERE ပြီးမှ JOIN တာသည် ပိုမြန်တယ်။ အဲ့လို Optimization ပေါင်းများစွာကို Query optimizer သည်လုပ်ရတယ်။ တခြား အချက်အလက်တွေ ဥပမာ index က ဘယ် key <a href="http://နဲ.ထားတာလဲ">နဲ.ထားတာလဲ</a> physically အရ ဘယ် block ပြီးရင် ဘယ်ကောင်ကို ခေါ်တင်ရင် disk access သက်သာမလဲ အစရှိတာတွေပါ ထဲ့စဉ်းစားတယ်။ ခြုံပြောရရင် User ရေးလိုက်တဲ့ SQL ကို heuristic algorithm တွေသုံးပြီး အဓိပ္ပာယ်မပျက်ပဲ <a href="http://ပိုမြန်အောင်လုပ်တယ်လို.ပဲဆိုရမယ်">ပိုမြန်အောင်လုပ်တယ်လို.ပဲဆိုရမယ်</a>။<br><br>Plan Executor<br>ဒီအဆင့်ကတော့ခုနက logical query plan ကို execute လုပ်တာပဲ။ဆိုချင်တာက database ရဲ. table တွေသည် hard disk မှာသိမ်းထားတာ အဲ့တော့ အဲ့ကောင်တွေကို JOIN လုပ်ဖို. select လုပ်ဖို. sort လုပ်ဖို. operation <a href="http://လေးတွေတခုချင်းဆီလိုက်လုပ်တာလို.ပြောရမယ်">လေးတွေတခုချင်းဆီလိုက်လုပ်တာလို.ပြောရမယ်</a>။ Physical storage မှာ မြန်မြန်ဆန်ဆန်နဲ. ရှာနိုင်ဖို. retrieve လုပ်နိုင်ဖို. ဘာကိုသုံးရသလဲဆိုရင် များသောအားဖြင့် B+ tree ဆိုတာကိုသုံးရတယ်။ B+ tree ဆိုတာ binary tree လိုသဘောပဲ ဒါပေသိ <a href="http://သူ.ရဲ">သူ.ရဲ</a>. internal node တွေသည် ထပ်ဆင့်ထပ်ဆင့် key တွေကိုသိမ်းသိမ်းသွားတဲ့အတွက် ရှာရပြုရတာ အင်မတန်မြန်တယ်။ မြင်သာအောင်ပြောရရင် phone contact list တွေမှာ A -Z စီထားသလိုပဲ ဘယ် record, ဘယ် primary key ဆိုရင် ဘယ်နားလောက်ရှိမယ်ဆိုတာကို ရှာရလွယ်တယ်။ Plan executor <a href="http://ရဲ.အလုပ်သည်">ရဲ.အလုပ်သည်</a> logical query plan ကို step by step execute လုပ်တာပဲ။ ခုနက record တွေ table row တွေကို ခေါ်တင်ဖို. <a href="http://ကျတော့ဘယ်သူ.ကို">ကျတော့ဘယ်သူ.ကို</a> ခိုင်းရလဲဆိုတော့ Transcational storage manager ကိုခိုင်းရရော။<br><br>Transcational storage manager<br>သူက CRUD operation တွေကိုလုပ်ရတယ်။ အဲ့လိုလုပ်တဲ့အခါမှာ RDBMS သည် ACID property ကို မဖောက်ဖျက်ရအောင် လိုက်နာရအောင် transcation manangement အတွက်ပါလုပ်ရတယ်။ တယောက်က row တခုကို update လုပ်နေချိန်မှာ နောက်တယောက်က ယူသုံးတာမျိုးမဖြစ်အောင် lock ချရတယ်။ အိမ်သာမှာ တယောက်က သုံးနေရင်နောက်တယောက် သုံးမရအောင် ချက် ချသလိုပေါ့။ အဲ့ဒါမျိုးကို lock manager ကလုပ်ရတယ်။ နောက်ဘယ်လို အဆင့်တွေ run သွားသလဲဆိုတာကို <a href="http://မှတ်ဖို.လိုတယ်">မှတ်ဖို.လိုတယ်</a>။ ဒါမှ roll back, commit ,logging အတွက်အဆင်ပြေမှာကိုး ။အဲ့ဒါတွေဖို. lock manager ကိုသုံးရတယ်။ နောက်တခုက database တခုသည် Gibabyte အများကြီးရှိနိုင်တယ်။ table <a href="http://တခုတည်းနဲ.တင်">တခုတည်းနဲ.တင်</a> နေရာအများကြီးယူနိုင်တယ်။အဲ့တော့ အဲ့ခုနက hard disk ပေါ်က row တွေ record တွေကို memory ပေါ်အားလုံး <a href="http://တင်ထားဖို.ဆိုတာမဖြစ်နိုင်ဘူး။အဲ့တော့">တင်ထားဖို.ဆိုတာမဖြစ်နိုင်ဘူး။အဲ့တော့</a> <a href="http://ဆန်.သလောက်လေးပဲ">ဆန်.သလောက်လေးပဲ</a> ထားရတယ်။ ဒါကို ကျတော့ Buffer manager ကလုပ်ရတာပေါ့။ Memory management <a href="http://နဲ.ပတ်သတ်တဲ့">နဲ.ပတ်သတ်တဲ့</a> caching လိုကောင်မျိုးကိုကျတော့ memory manager ကလုပ်ပေးရတယ်။ နောက် DDL and other processing Utilities ဆိုတာမျိုးကျတော့ ဥပမာ max တို. min တို. တခြား SQL မှာပါတဲ့ function တွေရဲ. implementation အပိုင်းကိုလုပ်ရတယ်။<br><br>Administration Monitoring ကျတော့ DBMS <a href="http://နဲ.ဆိုင်တဲ့">နဲ.ဆိုင်တဲ့</a> user role create လုပ်တာတို. access priviledge ထိန်းတာတို. monitoring <a href="http://လုပ်တာတို.ကိုတာဝန်ယူရတယ်">လုပ်တာတို.ကိုတာဝန်ယူရတယ်</a>။ Modern database တွေမှာ replicatation ပါလာတယ် အဲ့ကောင်တွေကျတော့ Replication and loading service ကလုပ်တယ်။ Batch execution ကျတော့ Batch utilities ကလုပ်ရတယ်။ Share component တွေ module <a href="http://တခုနဲ.တခု">တခုနဲ.တခု</a> communication ကျတော့ share component and utilities ကလုပ်ရတယ်။<br>မှတ်ချက် (နားမလည်ရင် ဖတ်တဲ့သူညံ့လို. နားလည်ရင် ရေးတဲ့သူတော်လို. 😛)<br>ကျမ်းကိုး <br><a href="http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf">http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf</a></body></html>