<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><br><a href="http://System.out.println">System.out.println</a> vs <a href="http://Console.WriteLine">Console.WriteLine</a><br><br>Java မှာ console ကို output ရိုက်ဖို့အတွက် သုံးတယ်။ C# ကတော့ <a href="http://Console.WriteLine">Console.WriteLine</a> ဆိုပြီးသုံးတယ်။ Java ရဲ့&nbsp; <a href="http://System.out.println">System.out.println</a> က Objecte Oriented Design perspective အရ ဘာတွေ လွဲနေသလဲပေါ့။<br><br>Java မှာ System ဆိုတာ class တခု။ အဲ့အထဲကမှ out ဆိုတာ PrintStream အမျိုးအစား public static final variable ပေါ့။ <br>နောက် println ဆိုတာကို PrintStream ထဲမှာ ဒီလိုရေးထားတာ။<br><br> public void println(String x) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (getClass() == <a href="http://PrintStream.class">PrintStream.class</a>) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writeln(<a href="http://String.valueOf">String.valueOf</a>(x));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized (this) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(x);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newLine();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>public static variable ဆိုတာ တကယ်က&nbsp; Global varible သဘောဆောင်တယ် code smell ပေါ့။ <br>Object Oriented program တွေမှာဆို global variable ကိုအားမပေးကြဘူး။ Memory ပေါ် program အစကနေ အဆုံးထိနေရာယူကြတယ်။<br>မသုံးတတ်ရင် Global variable တွေက memory leak ဖြစ်နိုင်တယ်( ဒီနေရာမှာ out က ဖြစ်တယ်လို့မဆိုလို).<br><br>နောက်တခုက System ရဲ့ out ဆိုတဲ့ variable ကို ယူသုံးတာသည် OO perspective အရကြည့်ရင် encapsulation ကိုချိုးဖောက်တယ် ခုနက global ဆိုတဲ့သဘောနဲ့တူတူပဲ။<br>ဘာဖြစ်လဲဆိုတော့ depend on abstraction not on implementation ဆိုတာကိုချိုးဖောက်တယ်။<br>abstraction မဟုတ်ပဲ implementation ဖြစ်တဲ့ PrintStream ကိုတိုက်ရိုက် couple ဖြစ်တဲ့အတွက်ပြုပြင်ရတာ ခက်မယ်. Open Closed Principle ကိုသွားထိတယ်ပေါ့။<br><br>နောက်တခုက println implementation မှာ&nbsp; if (getClass() == <a href="http://PrintStream.class">PrintStream.class</a>) ဆိုပြီး စစ်ထားတာ။ <br>ဒါက ဘာကိုချိုးဖောက်သလဲဆိုတော့ SOLID Principle ထဲက liskov substitution principle ကိုသွားထိတယ်။<br>ဆိုချင်တာက OO program တွေကို design လုပ်တဲ့အခါ parent reference နေရာမှာ child တွေအစားထိုးသုံးလို့ရဖို့လိုတယ်။<br>ဒါမှ polymorphism ကိုကောင်းကောင်းသုံးနိုင်မှာဖြစ်တယ်။ <br>child တွေနဲ့ parent reference ‌နေရာ အေးဆေး သုံးမရရင် polymorphism က အဆင်မပြေဘူး။ ဒါဆို open close principle ထဲက open for extension ဆိုတာ မအိုကေဘူး။<br>ခု getClass() == <a href="http://PrintStream.class">PrintStream.class</a> ဆိုတာ liskov substitution principle ကိုဖောက်ထားတဲ့သဘောပဲ။<br><br>နောက်ဆုံး violate လုပ်တဲ့ rule က demeter law ဆိုတာကိုပဲ။<br>သူက ဘာပြောလဲဆိုတော့ object တခုရဲ့ method က သုံးလို့ရတဲ့ ကောင်တွေ ဘာတွေလဲဆိုတော့<br>object ကိုယ်တိုင်ကိုသုံးလို့ရတယ်<br>method ဆီလာတဲ့ parameter တွေကိုသုံးလို့ရတယ် <br>m ထဲမှာဆောက်ထားတဲ့ object ‌တွေကိုသုံးလို့ရတယ် <br>object ရဲ့ attribute တွေသုံးလို့ရတယ်.<br><br>နားလည်အောင်ပြောရရင် a.b() ဆိုတဲ့ ၂ ဆင့်လောက်ပဲခေါ်သင့်တယ် a.b.c ဒါမျိုးခေါ်နေတာမျိုး ခွင့်မပေးဘူးပြောတာ။<br>ဘာလို့ကာထားသလဲဆိုတော့ coupling နည်းအောင် နောက်တခုက collaborator class တွေကို encapsulate ဖြစ်အောင်။<br>သူများ class ရဲ့ implementation ကို တဆင့်ချင်းလိုက်သုံးနေရတာ ဒါသည် encapsulation ကိုထိန်းမထားဘူးဆိုတဲ့သဘော<br><br>ဒါက Java ရဲ့ <a href="http://System.out.println">System.out.println</a> <br><br><a href="http://Console.WriteLine">Console.WriteLine</a> ကတော့ ရှင်းတယ် :P<br><br>ဒါဆို မသုံးရဘူးလားဆိုတော့ logging သုံးလို့ရတဲ့နေရာတွေမှာ မသုံးသင့်ဘူး (performance reason ကြောင့်)<br>သာမာန် အသေးသုံးတွေမှာသုံးလို့ရတယ် pragmatic ဘက်ကကြည့်ရင်<br>ဘာလို့ ဝေဘင်လဲဆိုတော့ အားနေလို့ (ကျောင်းသားတွေစာသင်းရင်းနဲ့ ချိန်ထိုးပြတာ)</body></html>